
@online{wesolowski_les_2021,
	title = {Les correcteurs automatiques ne seront jamais bons},
	url = {https://www.vice.com/fr/article/7k93be/les-correcteurs-automatiques-ne-seront-jamais-bons},
	abstract = {√áa fait 30 ans que nos appareils √©lectroniques nous font √©crire n'importe quoi, et √ßa ne semble pas pr√®s de changer.},
	titleaddon = {Vice},
	type = {blog},
	author = {Wesolowski, S√©bastien},
	urldate = {2022-01-05},
	date = {2021-03-01},
	langid = {french},
	keywords = {Grammaire, Intelligence Artificielle, Orthographe},
	file = {Snapshot:files/27/les-correcteurs-automatiques-ne-seront-jamais-bons.html:text/html},
}

@online{manjoo_votre_2010,
	title = {Votre portable essaie de deviner vos prochains messages},
	url = {http://www.slate.fr/story/25229/votre-portable-essaie-de-deviner-vos-prochains-messages},
	abstract = {Comment fonctionne le correcteur automatique de votre t√©l√©phone, et pourquoi il s'am√©liore.},
	titleaddon = {Slate.fr},
	author = {Manjoo, Farhad},
	urldate = {2022-01-05},
	date = {2010-07-26},
	langid = {french},
	note = {Section: Life},
	keywords = {Life, t√©l√©phone portable, technologie, {iPhone}},
	file = {Snapshot:files/29/votre-portable-essaie-de-deviner-vos-prochains-messages.html:text/html},
}

@online{noauthor_js_nodate,
	title = {{JS}: impl√©mentation de la saisie semi-automatique},
	url = {https://ichi.pro/fr/js-implementation-de-la-saisie-semi-automatique-269129727983625},
	shorttitle = {{JS}},
	abstract = {Vous √™tes-vous toujours demand√© comment fonctionne la compl√©tion automatique, eh bien, c'est super complexe dans la vraie vie avec l'apprentissage automatique et tout un tas de choses qui se passent dans le backend que je ne peux √©videmment pas construire tout seul! üòõ J'ai donc d√©cid√© de construire un prototype de travail assez similaire qui recherche un dictionnaire de mots anglais d'environ 102k mots (car c'est tout ce que j'ai pu trouver üò•) pour produire des suggestions d'auto-compl√©tion.},
	titleaddon = {{ICHI}.{PRO}},
	urldate = {2022-01-05},
	langid = {french},
	file = {Snapshot:files/31/js-implementation-de-la-saisie-semi-automatique-269129727983625.html:text/html},
}

@online{johnson_damn_2007,
	title = {Damn Cool Algorithms, Part 1: {BK}-Trees - Nick's Blog},
	url = {http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees},
	abstract = {This is the first post in (hopefully) a series of posts on Damn Cool Algorithms - essentially, any algorithm I think is really Damn Cool, particularly if it's simple but non-obvious.},
	titleaddon = {Nick's Blog},
	type = {blog},
	author = {Johnson, Nick},
	urldate = {2022-01-05},
	date = {2007-04-02},
	langid = {english},
	keywords = {coding, damn-cool-algorithms, technologie},
	file = {Damn Cool Algorithms, Part 1\: BK-Trees - Nick's Blog:files/33/Damn-Cool-Algorithms-Part-1-BK-Trees.html:text/html},
}

@online{johnson_damn_2010,
	title = {Damn Cool Algorithms: Levenshtein Automata - Nick's Blog},
	url = {http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata},
	abstract = {In a previous Damn Cool Algorithms post, I talked about {BK}-trees, a clever indexing structure that makes it possible to search for fuzzy matches on a text string based on Levenshtein distance - or any other metric that obeys the triangle inequality. Today, I'm going to describe an alternative approach, which makes it possible to do fuzzy text search in a regular index: Levenshtein automata.},
	titleaddon = {Nick's Blog},
	type = {blog},
	author = {Johnson, Nick},
	urldate = {2022-01-05},
	date = {2010-07-28},
	langid = {english},
	keywords = {coding, damn-cool-algorithms, technologie, python},
	file = {Damn Cool Algorithms\: Levenshtein Automata - Nick's Blog:files/35/Damn-Cool-Algorithms-Levenshtein-Automata.html:text/html},
}

@inreference{noauthor_autocomplete_2021,
	title = {Autocomplete},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Autocomplete&oldid=1062628465},
	abstract = {Autocomplete, or word completion, is a feature in which an application predicts the rest of a word a user is typing. In Android and {iOS} smartphones, this is called predictive text. In graphical user interfaces, users can typically press the tab key to accept a suggestion or the down arrow key to accept one of several.
Autocomplete speeds up human-computer interactions when it correctly predicts the word a user intends to enter after only a few characters have been typed into a text input field. It works best in domains with a limited number of possible words (such as in command line interpreters), when some words are much more common (such as when addressing an e-mail), or writing structured and predictable text (as in source code editors).
Many autocomplete algorithms learn new words after the user has written them a few times, and can suggest alternatives based on the learned habits of the individual user.},
	booktitle = {Wikipedia},
	urldate = {2022-01-05},
	date = {2021-12-29},
	langid = {english},
	note = {Page Version {ID}: 1062628465},
	file = {Snapshot:files/37/index.html:text/html},
}

@inreference{noauthor_predictive_2021,
	title = {Predictive text},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Predictive_text&oldid=1056470462},
	abstract = {Predictive text is an input technology used where one key or button represents many letters, such as on the numeric keypads of mobile phones and in accessibility technologies. Each key press results in a  prediction rather than repeatedly sequencing through the same group of "letters" it represents, in the same, invariable order.  Predictive text could allow for an entire word to be input by single keypress.  Predictive text makes efficient use of fewer device keys to input writing into a text message, an e-mail, an address book, a calendar, and the like.
The most widely used, general, predictive text systems are T9, {iTap}, {eZiText}, and {LetterWise}/{WordWise}.  There are many ways to build a device that predicts text, but all predictive text systems have initial linguistic settings that offer predictions that are re-prioritized to adapt to each user.  This learning adapts, by way of the device memory, to a user's disambiguating feedback that results in corrective key presses, such as pressing a "next" key to get to the intention. Most predictive text systems have a user database to facilitate this process.
Theoretically the number of keystrokes required per desired character in the finished writing is, on average, comparable to using a keyboard.  This is approximately true providing that all words used are in its database, punctuation is ignored, and no input mistakes are made typing or spelling.
The theoretical keystrokes per character, {KSPC}, of a keyboard is {KSPC}=1.00, and of multi-tap is {KSPC}=2.03. Eatoni's {LetterWise} is a predictive multi-tap hybrid, which when operating on a standard telephone keypad achieves {KSPC}=1.15 for English.
The choice of which predictive text system is the best to use involves matching the user's preferred interface style, the user's level of learned ability to operate predictive text software, and the user's efficiency goal. There are various levels of risk in predictive text systems, versus multi-tap systems, because the predicted text that is automatically written that provide the speed and mechanical efficiency benefit, could, if the user is not careful to review, result in transmitting misinformation.  Predictive text systems take time to learn to use well, and so generally, a device's system has user options to set up the choice of multi-tap or of any one of several schools of predictive text methods.},
	booktitle = {Wikipedia},
	urldate = {2022-01-05},
	date = {2021-11-22},
	langid = {english},
	note = {Page Version {ID}: 1056470462},
	file = {Snapshot:files/39/index.html:text/html},
}

@online{noauthor_comment_nodate,
	title = {Comment utiliser efficacement l'algorithme de Levenshtein pour la compl√©tion automatique du texte},
	url = {https://living-sun.com/fr/ios/317363-how-to-effectively-use-the-levenshtein-algorithm-for-text-auto-completion-ios-algorithm-levenshtein-distance.html},
	urldate = {2022-01-07},
	file = {Comment utiliser efficacement l'algorithme de Levenshtein pour la compl√©tion automatique du texte:files/41/317363-how-to-effectively-use-the-levenshtein-algorithm-for-text-auto-completion-ios-algorithm-.html:text/html},
}

@inreference{noauthor_arbre_2020,
	title = {Arbre radix},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Arbre_radix&oldid=175393004},
	abstract = {En informatique, un arbre radix ou arbre {PATRICIA} (pour Practical Algorithm To Retrieve Information Coded In Alphanumeric en anglais et signifiant algorithme commode pour extraire de l'information cod√©e en alphanum√©rique) est une structure de donn√©es compacte permettant de repr√©senter un ensemble de mots adapt√©e pour la recherche. Il est obtenu √† partir d'un arbre pr√©fixe en fusionnant chaque n≈ìud n'ayant qu'un seul fils avec celui-ci. On peut alors √©tiqueter indiff√©remment chaque ar√™te par un mot ou bien par une unique lettre.},
	booktitle = {Wikip√©dia},
	urldate = {2022-01-07},
	date = {2020-10-08},
	langid = {french},
	note = {Page Version {ID}: 175393004},
	file = {Snapshot:files/43/index.html:text/html},
}

@inreference{noauthor_chaine_nodate,
	title = {Cha√Æne de Markov},
	url = {https://fr.wikipedia.org/wiki/Cha%C3%AEne_de_Markov},
}

@misc{noauthor_chaine_nodate-1,
	title = {Cha√Æne de Markov 2},
	url = {https://www.imo.universite-paris-saclay.fr/~meliot/agreg/markov.pdf},
}

@inreference{noauthor_auto-completion_2019,
	title = {Auto-compl√©tion},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://fr.wikipedia.org/w/index.php?title=Auto-compl%C3%A9tion&oldid=165592185},
	abstract = {L'auto-compl√©tion ou autocompl√©tion ou compl√©tion automatique, souvent simplement compl√©tion, parfois compl√®tement ou compl√®tement automatique, est une fonctionnalit√© informatique permettant √† l'utilisateur de limiter la quantit√© d'informations qu'il saisit avec son clavier, en se voyant proposer un compl√©ment qui pourrait convenir √† la cha√Æne de caract√®res qu'il a commenc√© √† taper. De nombreux logiciels poss√®dent cette fonctionnalit√© : les √©diteurs de texte pr√©vus pour l'√©dition de code source, les traitements de texte, les interpr√©teurs de commandes ou encore les navigateurs web, ainsi que certains syst√®mes de saisie intuitive install√©s sur les t√©l√©phones mobiles.
La compl√©tion demande au logiciel de pouvoir pr√©voir le mot ou la phrase que l'utilisateur est susceptible de taper, avant que celui-ci ne l'ait enti√®rement saisi. Cette pr√©vision peut se faire :

√† partir des mots d√©j√† saisis, ailleurs dans le document en cours d'√©dition ou lors d'√©ditions pr√©c√©dentes ;
√† partir d'une ou plusieurs listes de mots ou dictionnaires, pr√©-√©tablis par l'utilisateur ou fournis avec le logiciel ;
√† partir de caract√©ristiques de l'application, par exemple les adresses d'un carnet d'adresses pour un client de messagerie, les marque-pages d'un navigateur web ou encore les fichiers d'un r√©pertoire ou les commandes dans l'interpr√©teur de commandes d'un syst√®me d'exploitation ;
la structure du document √©dit√© de l'utilisateur, par exemple la grammaire d'un langage informatique dans un √©diteur de code source.La compl√©tion permet d'acc√©l√©rer la saisie sur un ordinateur, ce qui rend l'interaction avec les logiciels moins p√©nible et plus efficace. Il permet √©galement de limiter les erreurs de saisie, en entrant sans intervention humaine les caract√®res qu'il reste √† taper. Cette derni√®re qualit√© se v√©rifie essentiellement sur les mots longs, pour lesquels il suffit de taper les premi√®res lettres.},
	booktitle = {Wikip√©dia},
	urldate = {2022-02-23},
	date = {2019-12-21},
	langid = {french},
	note = {Page Version {ID}: 165592185},
	file = {Snapshot:files/53/Auto-compl√©tion.html:text/html},
}

@online{noauthor_completion_nodate,
	title = {Compl√©tion ‚Äî Machine Learning, Statistiques et Programmation},
	url = {http://www.xavierdupre.fr/app/mlstatpy/helpsphinx/c_nlp/completion.html},
	urldate = {2022-02-24},
	file = {Compl√©tion ‚Äî Machine Learning, Statistiques et Programmation:files/55/completion.html:text/html},
}

@online{noauthor_definition_2021,
	title = {D√©finition Autocompl√©tion ou suggestion automatique},
	url = {https://www.twaino.com/definition/a/autocompletion/},
	abstract = {L'auto Compl√©tions reste un tabou pour la plupart des marketeurs. Retrouvez dans cet article ce que c'est et pourquoi l'utiliser pour le {SEO}.},
	titleaddon = {Twaino},
	urldate = {2022-04-29},
	date = {2021-08-25},
	langid = {french},
	note = {Section: A},
	file = {Snapshot:files/57/autocompletion.html:text/html},
}

@article{lehmann_examining_2021,
	title = {Examining Autocompletion as a Basic Concept for Interaction with Generative {AI}},
	volume = {19},
	issn = {2196-6826, 1618-162X},
	url = {http://arxiv.org/abs/2201.06892},
	doi = {10.1515/icom-2020-0025},
	abstract = {Autocompletion is an approach that extends and continues partial user input. We propose to interpret autocompletion as a basic interaction concept in human-{AI} interaction. We first describe the concept of autocompletion and dissect its user interface and interaction elements, using the well-established textual autocompletion in search engines as an example. We then highlight how these elements reoccur in other application domains, such as code completion, {GUI} sketching, and layouting. This comparison and transfer highlights an inherent role of such intelligent systems to extend and complete user input, in particular useful for designing interactions with and for generative {AI}. We reflect on and discuss our conceptual analysis of autocompletion to provide inspiration and a conceptual lens on current challenges in designing for human-{AI} interaction.},
	pages = {251--264},
	number = {3},
	journaltitle = {i-com},
	author = {Lehmann, Florian and Buschek, Daniel},
	urldate = {2022-05-08},
	date = {2021-01-26},
	eprinttype = {arxiv},
	eprint = {2201.06892},
	keywords = {Computer Science - Human-Computer Interaction},
	annotation = {Comment: This is an author version, see {DOI} for original article},
	file = {arXiv Fulltext PDF:files/60/Lehmann et Buschek - 2021 - Examining Autocompletion as a Basic Concept for In.pdf:application/pdf;arXiv.org Snapshot:files/61/2201.html:text/html},
}

@online{admin6658_combien_2020,
	title = {Combien de mots utilise-t-on ?},
	url = {https://plumelibre.fr/2020/08/combien-de-mots-utilise-t-on/},
	abstract = {Combien de mots utilise-t-on ? 300, 3000, 30000 ? De combien de mots environ a-t-on besoin pour parler une langue √©trang√®re ?},
	titleaddon = {Plume Libre},
	author = {{admin6658}},
	urldate = {2022-05-14},
	date = {2020-08-22},
	langid = {french},
	file = {Snapshot:files/63/combien-de-mots-utilise-t-on.html:text/html},
}

@online{noauthor_combien_nodate,
	title = {Combien de mots dans la langue fran√ßaise ?},
	url = {https://www.intercountry.com/blog/combien-de-mots-dans-la-langue-francaise},
	abstract = {Il faut bien donner un chiffre √† cette question ! Le fran√ßais courant, donc le vocabulaire que l‚Äôon utilise tous les jours, repr√©sente environ 32 000 mots...},
	urldate = {2022-05-14},
	langid = {french},
	file = {Snapshot:files/65/combien-de-mots-dans-la-langue-francaise.html:text/html},
}

@online{noauthor_quest_2021,
	title = {Qu'est ce que {GPT}-3 et pourquoi r√©volutionne t-il l'{IA} ?},
	url = {https://fr.yeeply.com/blog/gpt-3-revolutionnaire-de-lia/},
	abstract = {{GPT}-3 se d√©finit comme le plus grand r√©seau neuronal artificiel jamais cr√©√©. Nous expliquons ici comment il a √©t√© cr√©√© et comment fonctionne t-il ! üîç},
	titleaddon = {Yeeply},
	urldate = {2022-05-15},
	date = {2021-01-25},
	langid = {french},
	file = {Snapshot:files/67/gpt-3-revolutionnaire-de-lia.html:text/html},
}